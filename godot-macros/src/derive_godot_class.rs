/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use std::str::FromStr;

use crate::util::{bail, bail_error, ensure_kv_empty, ident, path_is_single, KvMap, KvValue};
use crate::{util, ParseResult};
use proc_macro2::{Ident, Punct, Span, TokenStream};
use quote::spanned::Spanned;
use quote::{format_ident, quote};
use venial::{Attribute, NamedField, Struct, StructFields, TyExpr};

// Property attribute argument strings.
const name_argument: &str = "name";
const getter_argument: &str = "getter";
const setter_argument: &str = "setter";

pub fn transform(input: TokenStream) -> ParseResult<TokenStream> {
    let decl = venial::parse_declaration(input)?;

    let class = decl
        .as_struct()
        .ok_or(venial::Error::new("Not a valid struct"))?;

    let struct_cfg = parse_struct_attributes(class)?;
    let fields = parse_fields(class)?;

    let base_ty = &struct_cfg.base_ty;
    let base_ty_str = struct_cfg.base_ty.to_string();
    let class_name = &class.name;
    let class_name_str = class.name.to_string();
    let inherits_macro = format_ident!("inherits_transitive_{}", &base_ty_str);

    let prv = quote! { ::godot::private };
    let deref_impl = make_deref_impl(class_name, &fields);

    let (godot_init_impl, create_fn);
    if struct_cfg.has_generated_init {
        godot_init_impl = make_godot_init_impl(class_name, fields);
        create_fn = quote! { Some(#prv::callbacks::create::<#class_name>) };
    } else {
        godot_init_impl = TokenStream::new();
        create_fn = quote! { None };
    };

    let godot_properties_impl = make_godot_properties_impl(class_name, struct_cfg.properties);

    Ok(quote! {
        impl ::godot::obj::GodotClass for #class_name {
            type Base = ::godot::engine::#base_ty;
            type Declarer = ::godot::obj::dom::UserDomain;
            type Mem = <Self::Base as ::godot::obj::GodotClass>::Mem;

            const CLASS_NAME: &'static str = #class_name_str;
        }

        #godot_init_impl
        #godot_properties_impl
        #deref_impl

        ::godot::sys::plugin_add!(__GODOT_PLUGIN_REGISTRY in #prv; #prv::ClassPlugin {
            class_name: #class_name_str,
            component: #prv::PluginComponent::ClassDef {
                base_class_name: #base_ty_str,
                generated_create_fn: #create_fn,
                free_fn: #prv::callbacks::free::<#class_name>,
            },
        });

        #prv::class_macros::#inherits_macro!(#class_name);
    })
}

/// Returns the name of the base and the default mode
fn parse_struct_attributes(class: &Struct) -> ParseResult<ClassAttributes> {
    let mut base = ident("RefCounted");
    //let mut new_mode = GodotConstructMode::AutoGenerated;
    let mut has_generated_init = false;

    // #[func] attribute on struct
    if let Some((span, mut map)) = parse_class_attr(&class.attributes)? {
        //println!(">>> CLASS {class}, MAP: {map:?}", class = class.name);

        if let Some(kv_value) = map.remove("base") {
            if let KvValue::Ident(override_base) = kv_value {
                base = override_base;
            } else {
                bail("Invalid value for 'base' argument", span)?;
            }
        }

        /*if let Some(kv_value) = map.remove("new") {
            match kv_value {
                KvValue::Ident(ident) if ident == "fn" => new_mode = GodotConstructMode::FnNew,
                KvValue::Ident(ident) if ident == "none" => new_mode = GodotConstructMode::None,
                _ => bail(
                    "Invalid value for 'new' argument; must be 'fn' or 'none'",
                    span,
                )?,
            }
        }*/
        if let Some(kv_value) = map.remove("init") {
            match kv_value {
                KvValue::None => has_generated_init = true,
                _ => bail("Argument 'init' must not have a value", span)?,
            }
        }
        ensure_kv_empty(&map, span)?;
    }

    Ok(ClassAttributes {
        base_ty: base,
        has_generated_init,
        properties: parse_property_attrs(&class.attributes)?,
    })
}

/// Returns field names and 1 base field, if available
fn parse_fields(class: &Struct) -> ParseResult<Fields> {
    let mut all_field_names = vec![];
    let mut exported_fields = vec![];
    let mut base_field = Option::<ExportedField>::None;

    let fields: Vec<(NamedField, Punct)> = match &class.fields {
        StructFields::Unit => {
            vec![]
        }
        StructFields::Tuple(_) => bail(
            "#[derive(GodotClass)] not supported for tuple structs",
            &class.fields,
        )?,
        StructFields::Named(fields) => fields.fields.inner.clone(),
    };

    // Attributes on struct fields
    for (field, _punct) in fields {
        let mut is_base = false;

        // #[base] or #[export]
        for attr in field.attributes.iter() {
            if let Some(path) = attr.get_single_path_segment() {
                if path == "base" {
                    is_base = true;
                    if let Some(prev_base) = base_field {
                        bail(
                            &format!(
                                "#[base] allowed for at most 1 field, already applied to '{}'",
                                prev_base.name
                            ),
                            attr,
                        )?;
                    }
                    base_field = Some(ExportedField::new(&field))
                } else if path == "export" {
                    exported_fields.push(ExportedField::new(&field))
                }
            }
        }

        // Exported or Rust-only fields
        if !is_base {
            all_field_names.push(field.name.clone())
        }
    }

    Ok(Fields {
        all_field_names,
        base_field,
    })
}

/// Parses a `#[class(...)]` attribute
fn parse_class_attr(attributes: &Vec<Attribute>) -> ParseResult<Option<(Span, KvMap)>> {
    let mut godot_attr = None;
    for attr in attributes.iter() {
        let path = &attr.path;
        if path_is_single(path, "class") {
            if godot_attr.is_some() {
                bail(
                    "Only one #[class] attribute per item (struct, fn, ...) allowed",
                    attr,
                )?;
            }

            let map = util::parse_kv_group(&attr.value)?;
            godot_attr = Some((attr.__span(), map));
        }
    }
    Ok(godot_attr)
}

/// Tries to remove and return the string literal value associcated with the given argument.
/// Either returns the value, or an error string explaining the issue that should be shown to the user.
fn require_property_string_argument(kv_map: &mut KvMap, argument: &str) -> Result<String, String> {
    if let Some(value) = kv_map.remove(argument) {
        if let KvValue::Lit(value) = value {
            return Ok(value);
        }
        return Err(format!(
            "#[property] attribute with a {} that isn't a string literal",
            argument
        ));
    } else {
        return Err(format!("#[property] attribute without any {}", argument));
    }
}

fn parse_property_attrs_from_kv_map<T: quote::ToTokens>(
    kv_map: &mut KvMap,
    tokens: &T,
) -> ParseResult<PropertyInfoAttribute> {
    // Parse all the required arguments, returning an error if any are missing.
    let name = require_property_string_argument(kv_map, name_argument)
        .map_err(|error_string: String| bail_error(error_string, tokens))?;
    let getter = require_property_string_argument(kv_map, getter_argument)
        .map_err(|error_string: String| bail_error(error_string, tokens))?;
    let setter = require_property_string_argument(kv_map, setter_argument)
        .map_err(|error_string: String| bail_error(error_string, tokens))?;
    // This is currently unused and unparsed.
    let variant_type: String = "".to_string();
    // Ensure no unhandled arguments are provided.
    ensure_kv_empty(kv_map, tokens.__span())?;

    return Ok(PropertyInfoAttribute {
        name: name,
        getter: getter,
        setter: setter,
        variant_type: variant_type,
    });
}

fn parse_property_attrs(attributes: &Vec<Attribute>) -> ParseResult<Vec<PropertyInfoAttribute>> {
    let mut property_attributes = Vec::<PropertyInfoAttribute>::new();
    for attr in attributes.iter() {
        let path = &attr.path;
        if path_is_single(path, "property") {
            property_attributes.push(parse_property_attrs_from_kv_map(
                &mut util::parse_kv_group(&attr.value)?,
                attr,
            )?);
        }
    }
    Ok(property_attributes)
}

// ----------------------------------------------------------------------------------------------------------------------------------------------
// General helpers

#[derive(Debug)]
struct PropertyInfoAttribute {
    name: String,
    getter: String,
    setter: String,
    variant_type: String,
}

struct ClassAttributes {
    base_ty: Ident,
    has_generated_init: bool,
    properties: Vec<PropertyInfoAttribute>,
}

struct Fields {
    all_field_names: Vec<Ident>,
    base_field: Option<ExportedField>,
}

struct ExportedField {
    name: Ident,
    _ty: TyExpr,
}

impl ExportedField {
    fn new(field: &NamedField) -> Self {
        Self {
            name: field.name.clone(),
            _ty: field.ty.clone(),
        }
    }
}

fn make_godot_init_impl(class_name: &Ident, fields: Fields) -> TokenStream {
    let base_init = if let Some(ExportedField { name, .. }) = fields.base_field {
        quote! { #name: base, }
    } else {
        TokenStream::new()
    };

    let rest_init = fields.all_field_names.into_iter().map(|field| {
        quote! { #field: std::default::Default::default(), }
    });

    quote! {
        impl ::godot::obj::cap::GodotInit for #class_name {
            fn __godot_init(base: ::godot::obj::Base<Self::Base>) -> Self {
                Self {
                    #( #rest_init )*
                    #base_init
                }
            }
        }
    }
}

fn make_godot_properties_impl(
    class_name: &Ident,
    properties: Vec<PropertyInfoAttribute>,
) -> TokenStream {
    let property_info_tokens =
        properties
            .into_iter()
            .map(|property_info: PropertyInfoAttribute| -> TokenStream {
                let name = proc_macro2::Literal::from_str(&property_info.name).unwrap();
                let getter = proc_macro2::Literal::from_str(&property_info.getter).unwrap();
                let setter = proc_macro2::Literal::from_str(&property_info.setter).unwrap();
                let variant_type = property_info.variant_type;
                quote! {
                    let class_name = StringName::from(#class_name::CLASS_NAME);
                    let property_info = ::godot::builtin::meta::PropertyInfo::new(
                        //#variant_type,
                        ::godot::sys::VariantType::Int,
                        ::godot::builtin::meta::ClassName::new::<#class_name>(),
                        StringName::from(#name),
                    );
                    let property_info_sys = property_info.property_sys();

                    let getter_string_name = StringName::from(#getter);
                    let setter_string_name = StringName::from(#setter);
                    unsafe {
                        ::godot::sys::interface_fn!(classdb_register_extension_class_property)(
                            ::godot::sys::get_library(),
                            class_name.string_sys(),
                            ::std::ptr::addr_of!(property_info_sys),
                            setter_string_name.string_sys(),
                            getter_string_name.string_sys(),
                        );
                    }
                }
            });
    quote! {
        impl ::godot::obj::cap::GodotProperties for #class_name {

            fn __register_properties() {
                use godot::builtin::StringName;
                use godot::builtin::meta::PropertyInfo;
                #(
                    {
                        #property_info_tokens
                    }
                )*
            }
        }
    }
}

fn make_deref_impl(class_name: &Ident, fields: &Fields) -> TokenStream {
    let base_field = if let Some(ExportedField { name, .. }) = &fields.base_field {
        name
    } else {
        return TokenStream::new();
    };

    quote! {
        impl std::ops::Deref for #class_name {
            type Target = <Self as ::godot::obj::GodotClass>::Base;

            fn deref(&self) -> &Self::Target {
                &*self.#base_field
            }
        }
        impl std::ops::DerefMut for #class_name {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut *self.#base_field
            }
        }
    }
}

// ----------------------------------------------------------------------------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use proc_macro2::TokenStream;
    use quote::quote;

    macro_rules! hash_map {
        (
            $($key:expr => $value:expr),*
            $(,)?
        ) => {
            {
                let mut map = std::collections::HashMap::new();
                $(
                    map.insert($key, $value);
                )*
                map
            }
        };
    }

    fn expect_parse_error<T: quote::ToTokens>(mut kv_map: KvMap, tokens: &T) {
        assert!(parse_property_attrs_from_kv_map(&mut kv_map, tokens).is_err());
    }

    fn full_properties() -> KvMap {
        hash_map!(
            name_argument.to_string() => KvValue::Lit("\"test1\"".to_string()),
            getter_argument.to_string() => KvValue::Lit("\"test2\"".to_string()),
            setter_argument.to_string() => KvValue::Lit("\"test3\"".to_string()),
        )
    }

    #[test]
    fn test_properties_sucessful() {
        assert!(parse_property_attrs_from_kv_map(&mut full_properties(), &quote! {}).is_ok());
    }

    #[test]
    fn test_properties_missing_fields() {
        fn remove_and_return(mut map: KvMap, key: &str) -> KvMap {
            map.remove(key);
            return map;
        }
        expect_parse_error(
            remove_and_return(full_properties(), name_argument),
            &quote! {},
        );
        expect_parse_error(
            remove_and_return(full_properties(), getter_argument),
            &quote! {},
        );
        expect_parse_error(
            remove_and_return(full_properties(), setter_argument),
            &quote! {},
        );
    }

    #[test]
    fn test_properties_not_literal() {
        fn make_property_not_literal(mut map: KvMap, key: &str) -> KvMap {
            map.insert(
                key.to_string(),
                KvValue::Ident(Ident::new("testIdent", Span::call_site())),
            );
            return map;
        }
        expect_parse_error(
            make_property_not_literal(full_properties(), name_argument),
            &quote! {},
        );
        expect_parse_error(
            make_property_not_literal(full_properties(), getter_argument),
            &quote! {},
        );
        expect_parse_error(
            make_property_not_literal(full_properties(), setter_argument),
            &quote! {},
        );
    }
}
